{"version":3,"file":"index.min.js","sources":["../../src/tracking/index.js"],"sourcesContent":["/**\n * @fileoverview Module de tracking d'activité utilisateur avec détection d'événements suspects\n * @module quizaccess_cheatdetect/tracking/index\n * @copyright 2025 CBlue SRL <support@cblue.be>\n * @license http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n * @since 1.0.0\n */\n\ndefine([\n    'quizaccess_cheatdetect/extension-detector/index',\n    'quizaccess_cheatdetect/shared/utils'\n], function(ExtensionDetector, SharedUtils) {\n    'use strict';\n\n    /**\n     * @typedef {Object} BackendParams\n     * @property {boolean} [startDetection=true] - Active/désactive le tracking\n     * @property {string} [sessionId] - ID de session\n     * @property {number} [attemptid] - ID de la tentative\n     * @property {number} [userid] - ID de l'utilisateur\n     * @property {number} [quizid] - ID du quiz\n     * @property {number} [slot] - Numéro de slot de question\n     */\n\n    var init = function(backendParams) {\n        // Ne rien faire si startDetection n'est pas explicitement true\n        if (backendParams.startDetection !== true) {\n            console.log('Tracking désactivé: startDetection !== true');\n            return;\n        }\n\n        const userActivityTracker = () => {\n            let db = null;\n            let isCurrentlyFocused = !document.hidden;\n\n            let lastKnownExtensions = {};\n            let extensionCheckInterval = null;\n            let extensionDetectedDataAlreadySent = new Set();\n\n            /**\n             *\n             */\n            function getExtensionsMetrics() {\n                try {\n                    const metricsJSON = ExtensionDetector.getMetrics();\n\n                    const metrics = JSON.parse(metricsJSON);\n\n                    if (!metrics.timestamp || !metrics.extensionDetection) {\n                        console.warn('Extension Detector: Structure de métriques invalide reçue');\n                        return {};\n                    }\n\n                    return metrics.extensionDetection;\n\n                } catch (error) {\n                    console.warn('Extension Detector: Erreur lors de la récupération des métriques d\\'extension:', error);\n                    return {};\n                }\n            }\n\n            /**\n             *\n             */\n            function checkForNewExtensions() {\n                const currentExtensions = getExtensionsMetrics();\n                const newData = [];\n\n                for (const [key, value] of Object.entries(currentExtensions)) {\n                    for (const detectedElement of value.detected) {\n                        const _data = JSON.stringify({extensionKey: key, detectedElementUid: detectedElement.uid});\n                        if (!extensionDetectedDataAlreadySent.has(_data)) {\n                            extensionDetectedDataAlreadySent.add(_data);\n                            newData.push(detectedElement);\n                        }\n                    }\n                }\n\n                if (newData.length > 0) {\n                    logEvent({\n                        action: \"extensions_detected\",\n                        data: newData\n                    });\n                }\n            }\n\n            /**\n             *\n             */\n            function startExtensionMonitoring() {\n                checkForNewExtensions();\n\n                const initialExtensions = getExtensionsMetrics();\n                lastKnownExtensions = initialExtensions;\n\n                extensionCheckInterval = setInterval(() => {\n                    checkForNewExtensions();\n                }, 5000);\n            }\n\n            /**\n             *\n             */\n            function stopExtensionMonitoring() {\n                if (extensionCheckInterval) {\n                    clearInterval(extensionCheckInterval);\n                    extensionCheckInterval = null;\n                }\n            }\n\n            /**\n             *\n             */\n            function checkIndexedDBAvailability() {\n                return window.indexedDB;\n            }\n\n            /**\n             *\n             */\n            function initIndexedDB() {\n                return new Promise((resolve, reject) => {\n                    if (!checkIndexedDBAvailability()) {\n                        reject(\"IndexedDB n'est pas disponible.\");\n                        return;\n                    }\n\n                    const request = indexedDB.open(\"UserActivityDB\", 1);\n\n                    request.onupgradeneeded = (event) => {\n                        const database = event.target.result;\n                        if (!database.objectStoreNames.contains(\"events\")) {\n                            database.createObjectStore(\"events\", {autoIncrement: true});\n                        }\n                    };\n\n                    request.onsuccess = (event) => {\n                        db = event.target.result;\n                        resolve();\n                    };\n\n                    request.onerror = (event) => {\n                        console.error(\"Erreur lors de l'ouverture d'IndexedDB:\", event.target.error);\n                        reject(event.target.error);\n                    };\n                });\n            }\n\n            /**\n             *\n             * @param newEvent\n             */\n            function logEvent(newEvent) {\n                if (db) {\n                    const transaction = db.transaction(\"events\", \"readwrite\");\n                    const objectStore = transaction.objectStore(\"events\");\n\n                    const _newEvent = {\n                        timestamp: SharedUtils.generateTimestamp(),\n                        ...newEvent\n                    };\n\n                    console.log('Nouvelle action utilisateur stockée', _newEvent);\n                    objectStore.add(_newEvent);\n                }\n            }\n\n\n            /**\n             *\n             * @param event\n             */\n            function trackDocumentState(event) {\n                const now = performance.now();\n                let type = event.type;\n\n                if (event.type === 'visibilitychange') {\n                    if (document.visibilityState === 'visible') {\n                        type = 'focus';\n                    } else if (document.visibilityState === 'hidden') {\n                        type = 'blur';\n                    }\n                }\n\n                if (type === 'focus') {\n                    if (!isCurrentlyFocused) {\n                        isCurrentlyFocused = true;\n\n                        const focusEvent = {\n                            action: \"page_foreground\",\n                            data: {\n                                previousState: \"background\"\n                            }\n                        };\n                        logEvent(focusEvent);\n                    }\n                } else if (type === 'blur') {\n                    if (isCurrentlyFocused) {\n                        isCurrentlyFocused = false;\n\n                        const blurEvent = {\n                            action: \"page_background\",\n                            data: {\n                                previousState: \"foreground\"\n                            }\n                        };\n                        logEvent(blurEvent);\n                    }\n                }\n            }\n\n            /**\n             * Track copy events only within .qtext elements inside question divs\n             * @param event\n             */\n            function trackCopy(event) {\n                const selection = window.getSelection();\n                const copiedText = selection.toString();\n\n                if (!copiedText) {\n                    return;\n                }\n\n                // Check if the selection is within a .qtext element\n                const anchorNode = selection.anchorNode;\n                if (!anchorNode) {\n                    return;\n                }\n\n                // Get the parent element (anchorNode might be a text node)\n                let element = anchorNode.nodeType === Node.TEXT_NODE ? anchorNode.parentElement : anchorNode;\n\n                // Traverse up to find .qtext element\n                let qtextElement = null;\n                let currentElement = element;\n                while (currentElement && currentElement !== document.body) {\n                    if (currentElement.classList && currentElement.classList.contains('qtext')) {\n                        qtextElement = currentElement;\n                        break;\n                    }\n                    currentElement = currentElement.parentElement;\n                }\n\n                if (!qtextElement) {\n                    return; // Not inside a .qtext element\n                }\n\n                // Check if .qtext is inside a question div with id pattern question-x-y\n                let questionElement = null;\n                currentElement = qtextElement;\n                const questionIdPattern = /^question-\\d+-\\d+$/;\n\n                while (currentElement && currentElement !== document.body) {\n                    if (currentElement.id && questionIdPattern.test(currentElement.id)) {\n                        questionElement = currentElement;\n                        break;\n                    }\n                    currentElement = currentElement.parentElement;\n                }\n\n                if (!questionElement) {\n                    return; // Not inside a valid question div\n                }\n\n                // Log the copy event with question context\n                const newEvent = {\n                    action: \"copy\",\n                    data: {\n                        content: copiedText,\n                        questionId: questionElement.id\n                    }\n                };\n                logEvent(newEvent);\n            }\n\n\n            /**\n             *\n             */\n            function initTracking() {\n                if (window._trackingInitialized) {\n                    console.warn('Tracking déjà initialisé, ignoré');\n                    return;\n                }\n                window._trackingInitialized = true;\n\n                const pageLoadEvent = {\n                    action: \"page_load\",\n                    data: {\n                        url: window.location.href,\n                        referrer: document.referrer || null,\n                        userAgent: navigator.userAgent\n                    }\n                };\n                logEvent(pageLoadEvent);\n\n                // Démarrer le détecteur d'extensions\n                ExtensionDetector.init(backendParams);\n\n                startExtensionMonitoring();\n\n                document.addEventListener(\"visibilitychange\", trackDocumentState);\n\n                document.addEventListener(\"blur\", trackDocumentState, true);\n\n                window.addEventListener(\"focus\", trackDocumentState);\n\n                window.addEventListener(\"blur\", trackDocumentState);\n\n                document.addEventListener(\"copy\", (event) => trackCopy(event));\n\n                window.addEventListener(\"beforeunload\", () => {\n                    stopExtensionMonitoring();\n\n                    const pageUnloadEvent = {\n                        action: \"page_unload\",\n                        data: {}\n                    };\n                    logEvent(pageUnloadEvent);\n\n                    flushEvents();\n                });\n\n                trackDocumentState({type: 'visibilitychange'});\n            }\n\n            /**\n             *\n             */\n            function flushEvents() {\n                if (db) {\n                    const transaction = db.transaction(\"events\", \"readonly\");\n                    const objectStore = transaction.objectStore(\"events\");\n                    const request = objectStore.getAll();\n\n                    request.onsuccess = () => {\n                        const events = request.result;\n                        if (events.length > 0) {\n                            const data = {\n                                session_id: backendParams.sessionId,\n                                attemptid: backendParams.attemptid,\n                                userid: backendParams.userid,\n                                quizid: backendParams.quizid,\n                                slot: backendParams.slot,\n                                events: events\n                            };\n\n                            fetch('/local/rest/api/quizaccess_cheatdetect/save-data', {\n                                method: 'POST',\n                                headers: {\n                                    'Content-Type': 'application/json'\n                                },\n                                body: JSON.stringify(data)\n                            }).then(response => {\n                                if (response.ok) {\n                                    console.log('Action(s) utilisateur envoyée(s) au serveur', data);\n                                    clearStoredEvents();\n                                } else {\n                                    console.error('Erreur lors de l\\'envoi des événements');\n                                }\n                            }).catch(error => {\n                                console.error('Erreur réseau:', error);\n                            });\n                        } else {\n                            console.log('Aucune action utilisateur à sauvegarder');\n                        }\n                    };\n\n                    request.onerror = (error) => {\n                        console.error(\"Erreur lors de la récupération des événements depuis IndexedDB:\", error);\n                    };\n                }\n            }\n\n            /**\n             *\n             */\n            function clearStoredEvents() {\n                const transaction = db.transaction(\"events\", \"readwrite\");\n                const objectStore = transaction.objectStore(\"events\");\n                objectStore.clear();\n            }\n\n            initIndexedDB().then(() => {\n                initTracking();\n                setInterval(() => {\n                    flushEvents();\n                }, 5000);\n            }).catch((error) => {\n                console.error(\"Échec de l'initialisation d'IndexedDB:\", error);\n            });\n        };\n\n        userActivityTracker();\n    };\n\n    return {\n        init: init\n    };\n});\n"],"names":["define","ExtensionDetector","SharedUtils","init","backendParams","startDetection","console","log","userActivityTracker","db","isCurrentlyFocused","document","hidden","lastKnownExtensions","extensionCheckInterval","extensionDetectedDataAlreadySent","Set","getExtensionsMetrics","metricsJSON","getMetrics","metrics","JSON","parse","timestamp","extensionDetection","warn","error","checkForNewExtensions","currentExtensions","newData","key","value","Object","entries","detectedElement","detected","_data","stringify","extensionKey","detectedElementUid","uid","has","add","push","length","logEvent","action","data","newEvent","objectStore","transaction","_newEvent","_objectSpread","generateTimestamp","trackDocumentState","event","performance","now","type","visibilityState","previousState","initTracking","window","_trackingInitialized","url","location","href","referrer","userAgent","navigator","initialExtensions","setInterval","startExtensionMonitoring","addEventListener","selection","getSelection","copiedText","toString","anchorNode","qtextElement","currentElement","nodeType","Node","TEXT_NODE","parentElement","body","classList","contains","questionElement","questionIdPattern","id","test","content","questionId","trackCopy","clearInterval","flushEvents","request","getAll","onsuccess","events","result","session_id","sessionId","attemptid","userid","quizid","slot","fetch","method","headers","then","response","ok","clear","clearStoredEvents","catch","onerror","Promise","resolve","reject","indexedDB","open","onupgradeneeded","database","target","objectStoreNames","createObjectStore","autoIncrement"],"mappings":"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"}
{"version":3,"file":"index.min.js","sources":["../../src/tracking/index.js"],"sourcesContent":["/**\n * @fileoverview User activity tracking module with suspicious event detection\n * @module quizaccess_cheatdetect/tracking/index\n * @copyright 2025 CBlue SRL <support@cblue.be>\n * @license http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n * @since 1.0.0\n */\n\ndefine([\n    'core/ajax',\n    'quizaccess_cheatdetect/extension-detector/index',\n    'quizaccess_cheatdetect/shared/utils'\n], function(Ajax, ExtensionDetector, SharedUtils) {\n    'use strict';\n\n    const DEBUG_SHOW_CONSOLE_LOG = false;\n\n    /**\n     * @typedef {Object} BackendParams\n     * @property {boolean} [startDetection=true] - Enable/disable tracking\n     * @property {string} [sessionId] - Session ID\n     * @property {number} [attemptid] - Attempt ID\n     * @property {number} [userid] - User ID\n     * @property {number} [quizid] - Quiz ID\n     * @property {number} [slot] - Question slot number\n     */\n\n    /**\n     * Initialize the user activity tracking module\n     * Sets up event listeners and IndexedDB for storing tracking data\n     * @function init\n     * @param {BackendParams} backendParams - Configuration parameters from backend\n     * @returns {void}\n     * @since 1.0.0\n     */\n    const init = function(backendParams) {\n        // Do nothing if startDetection is not explicitly true\n        if (backendParams.startDetection !== true) {\n            if (DEBUG_SHOW_CONSOLE_LOG) {\n                // eslint-disable-next-line no-console\n                console.log('Tracking disabled: startDetection !== true');\n            }\n            return;\n        }\n\n        const userActivityTracker = () => {\n            let db = null;\n            let isCurrentlyFocused = !document.hidden;\n\n            let extensionCheckInterval = null;\n            let extensionDetectedDataAlreadySent = new Set();\n\n            /**\n             * Retrieve current extension detection metrics\n             * @function getExtensionsMetrics\n             * @returns {Object} Extension detection metrics object\n             * @private\n             */\n            function getExtensionsMetrics() {\n                try {\n                    const metricsJSON = ExtensionDetector.getMetrics();\n\n                    const metrics = JSON.parse(metricsJSON);\n\n                    if (!metrics.timestamp || !metrics.extensionDetection) {\n                        // eslint-disable-next-line no-console\n                        console.warn('Extension Detector: Invalid metrics structure received');\n                        return {};\n                    }\n\n                    return metrics.extensionDetection;\n\n                } catch (error) {\n                    // eslint-disable-next-line no-console\n                    console.warn('Extension Detector: Error retrieving extension metrics:', error);\n                    return {};\n                }\n            }\n\n            /**\n             * Check for newly detected extensions and log them\n             * Compares current metrics with already sent data to avoid duplicates\n             * @function checkForNewExtensions\n             * @returns {void}\n             * @private\n             */\n            function checkForNewExtensions() {\n                const currentExtensions = getExtensionsMetrics();\n                const newData = [];\n\n                for (const [key, value] of Object.entries(currentExtensions)) {\n                    for (const detectedElement of value.detected) {\n                        const _data = JSON.stringify({extensionKey: key, detectedElementUid: detectedElement.uid});\n                        if (!extensionDetectedDataAlreadySent.has(_data)) {\n                            extensionDetectedDataAlreadySent.add(_data);\n                            newData.push({\n                                extensionKey: key,\n                                uid: detectedElement.uid ?? null,\n                                name: detectedElement.name ?? null\n                            });\n                        }\n                    }\n                }\n\n                if (newData.length > 0) {\n                    logEvent({\n                        action: \"extensions_detected\",\n                        data: newData\n                    });\n                }\n            }\n\n            /**\n             * Start periodic extension monitoring\n             * Checks for new extensions every 5 seconds\n             * @function startExtensionMonitoring\n             * @returns {void}\n             * @private\n             */\n            function startExtensionMonitoring() {\n                checkForNewExtensions();\n\n                extensionCheckInterval = setInterval(() => {\n                    checkForNewExtensions();\n                }, 5000);\n            }\n\n            /**\n             * Stop extension monitoring interval\n             * @function stopExtensionMonitoring\n             * @returns {void}\n             * @private\n             */\n            function stopExtensionMonitoring() {\n                if (extensionCheckInterval) {\n                    clearInterval(extensionCheckInterval);\n                    extensionCheckInterval = null;\n                }\n            }\n\n            /**\n             * Check if IndexedDB is available in the browser\n             * @function checkIndexedDBAvailability\n             * @returns {IDBFactory|undefined} IndexedDB factory or undefined\n             * @private\n             */\n            function checkIndexedDBAvailability() {\n                return window.indexedDB;\n            }\n\n            /**\n             * Initialize IndexedDB database for storing user activity events\n             * @function initIndexedDB\n             * @returns {Promise<void>} Promise that resolves when database is ready\n             * @private\n             */\n            function initIndexedDB() {\n                return new Promise((resolve, reject) => {\n                    if (!checkIndexedDBAvailability()) {\n                        reject(\"IndexedDB is not available.\");\n                        return;\n                    }\n\n                    const request = indexedDB.open(\"UserActivityDB\", 1);\n\n                    request.onupgradeneeded = (event) => {\n                        const database = event.target.result;\n                        if (!database.objectStoreNames.contains(\"events\")) {\n                            database.createObjectStore(\"events\", {autoIncrement: true});\n                        }\n                    };\n\n                    request.onsuccess = (event) => {\n                        db = event.target.result;\n                        resolve();\n                    };\n\n                    request.onerror = (event) => {\n                        // eslint-disable-next-line no-console\n                        console.error(\"Error opening IndexedDB:\", event.target.error);\n                        reject(event.target.error);\n                    };\n                });\n            }\n\n            /**\n             * Log a user activity event to IndexedDB\n             * @function logEvent\n             * @param {Object} newEvent - Event object to store\n             * @param {string} newEvent.action - Type of action (e.g., 'copy', 'page_load')\n             * @param {Object} newEvent.data - Additional event data\n             * @returns {void}\n             * @private\n             */\n            function logEvent(newEvent) {\n                if (db) {\n                    const transaction = db.transaction(\"events\", \"readwrite\");\n                    const objectStore = transaction.objectStore(\"events\");\n\n                    const _newEvent = {\n                        timestamp: {\n                            unix: SharedUtils.generateTimestamp().unix\n                        },\n                        action: newEvent.action,\n                        data: newEvent.data !== undefined && newEvent.data !== null\n                            ? JSON.stringify(newEvent.data)\n                            : null\n                    };\n\n                    if (DEBUG_SHOW_CONSOLE_LOG) {\n                        // eslint-disable-next-line no-console\n                        console.log('New user action stored', JSON.stringify(_newEvent, null, 2));\n                    }\n                    objectStore.add(_newEvent);\n                }\n            }\n\n            /**\n             * Track document visibility state changes (focus/blur)\n             * @function trackDocumentState\n             * @param {Event} event - Visibility change or focus/blur event\n             * @returns {void}\n             * @private\n             */\n            function trackDocumentState(event) {\n                let type = event.type;\n\n                // Ignore blur/focus events from form elements (INPUT, BUTTON, etc.)\n                // We only care about window/document level visibility changes\n                if ((event.type === 'blur' || event.type === 'focus') && event.target !== window) {\n                    return;\n                }\n\n                if (event.type === 'visibilitychange') {\n                    if (document.visibilityState === 'visible') {\n                        type = 'focus';\n                    } else if (document.visibilityState === 'hidden') {\n                        type = 'blur';\n                    }\n                }\n\n                if (type === 'focus') {\n                    if (!isCurrentlyFocused) {\n                        isCurrentlyFocused = true;\n\n                        const focusEvent = {\n                            action: \"focus_gain\",\n                            data: {\n                                previousState: \"background\"\n                            }\n                        };\n                        logEvent(focusEvent);\n                    }\n                } else if (type === 'blur') {\n                    if (isCurrentlyFocused) {\n                        isCurrentlyFocused = false;\n\n                        const blurEvent = {\n                            action: \"focus_loss\",\n                            data: {\n                                previousState: \"foreground\"\n                            }\n                        };\n                        logEvent(blurEvent);\n                    }\n                }\n            }\n\n            /**\n             * Track copy events only within .qtext elements inside question divs\n             * Only logs copies from question text areas to detect potential cheating\n             * @function trackCopy\n             * @param {ClipboardEvent} event - Copy event from document\n             * @returns {void}\n             * @private\n             */\n            function trackCopy(event) { // eslint-disable-line no-unused-vars\n                const selection = window.getSelection();\n                const copiedText = selection.toString();\n\n                if (!copiedText) {\n                    return;\n                }\n\n                // Check if the selection is within a .qtext element\n                const anchorNode = selection.anchorNode;\n                if (!anchorNode) {\n                    return;\n                }\n\n                // Get the parent element (anchorNode might be a text node)\n                let element = anchorNode.nodeType === Node.TEXT_NODE ? anchorNode.parentElement : anchorNode;\n\n                // Traverse up to find .qtext element\n                let qtextElement = null;\n                let currentElement = element;\n                while (currentElement && currentElement !== document.body) {\n                    if (currentElement.classList && currentElement.classList.contains('qtext')) {\n                        qtextElement = currentElement;\n                        break;\n                    }\n                    currentElement = currentElement.parentElement;\n                }\n\n                if (!qtextElement) {\n                    return; // Not inside a .qtext element\n                }\n\n                // Check if .qtext is inside a question div with id pattern question-x-y\n                let questionElement = null;\n                currentElement = qtextElement;\n                const questionIdPattern = /^question-\\d+-\\d+$/;\n\n                while (currentElement && currentElement !== document.body) {\n                    if (currentElement.id && questionIdPattern.test(currentElement.id)) {\n                        questionElement = currentElement;\n                        break;\n                    }\n                    currentElement = currentElement.parentElement;\n                }\n\n                if (!questionElement) {\n                    return; // Not inside a valid question div\n                }\n\n                // Log the copy event with question context\n                const newEvent = {\n                    action: \"copy\",\n                    data: {\n                        content: copiedText,\n                        questionId: questionElement.id\n                    }\n                };\n                logEvent(newEvent);\n            }\n\n\n            /**\n             * Initialize all tracking event listeners\n             * Sets up listeners for visibility, focus, copy, and unload events\n             * @function initTracking\n             * @returns {void}\n             * @private\n             */\n            function initTracking() {\n                if (window._trackingInitialized) {\n                    if (DEBUG_SHOW_CONSOLE_LOG) {\n                        // eslint-disable-next-line no-console\n                        console.warn('Tracking already initialized, skipped');\n                    }\n                    return;\n                }\n                window._trackingInitialized = true;\n\n                const pageLoadEvent = {\n                    action: \"page_load\",\n                    data: {\n                        url: window.location.href,\n                        referrer: document.referrer || null,\n                        userAgent: navigator.userAgent\n                    }\n                };\n                logEvent(pageLoadEvent);\n\n                // Start extension detector\n                ExtensionDetector.init(backendParams);\n\n                startExtensionMonitoring();\n\n                document.addEventListener(\"visibilitychange\", trackDocumentState);\n\n                document.addEventListener(\"blur\", trackDocumentState, true);\n\n                window.addEventListener(\"focus\", trackDocumentState);\n\n                window.addEventListener(\"blur\", trackDocumentState);\n\n                document.addEventListener(\"copy\", (event) => trackCopy(event));\n\n                window.addEventListener(\"beforeunload\", () => {\n                    stopExtensionMonitoring();\n\n                    const pageUnloadEvent = {\n                        action: \"page_unload\",\n                        data: {}\n                    };\n                    logEvent(pageUnloadEvent);\n\n                    flushEvents();\n                });\n\n                trackDocumentState({type: 'visibilitychange'});\n            }\n\n            /**\n             * Filter out spurious page_background events caused by page navigation\n             * @function filterSpuriousEvents\n             * @param {Array} events - Array of events to filter\n             * @returns {Array} Filtered events array\n             * @private\n             */\n            function filterSpuriousEvents(events) {\n                return events.filter((event, index, arr) => {\n                    if (event.action === \"focus_loss\" && index < arr.length - 1) {\n                        const nextAction = arr[index + 1].action;\n                        // Remove page_background if immediately followed by page_unload or page_load\n                        // (page_load means it's an orphan from previous navigation)\n                        if (nextAction === \"page_unload\" || nextAction === \"page_load\") {\n                            return false;\n                        }\n                    }\n                    return true;\n                });\n            }\n\n            /**\n             * Send all stored events to the server via REST API\n             * Clears local storage after successful transmission\n             * @function flushEvents\n             * @returns {void}\n             * @private\n             */\n            function flushEvents() {\n                if (db) {\n                    const transaction = db.transaction(\"events\", \"readonly\");\n                    const objectStore = transaction.objectStore(\"events\");\n                    const request = objectStore.getAll();\n\n                    request.onsuccess = () => {\n                        const events = filterSpuriousEvents(request.result).map(event => {\n                            return {\n                                action: event.action,\n                                timestamp: {\n                                    unix: event.timestamp?.unix ?? event.timestamp\n                                },\n                                data: event.data !== undefined && event.data !== null\n                                    ? (typeof event.data === 'string'\n                                        ? event.data\n                                        : JSON.stringify(event.data))\n                                    : null\n                            };\n                        });\n\n                        if (events.length > 0) {\n                            Ajax.call([{\n                                methodname: 'quizaccess_cheatdetect_save_data',\n                                args: {\n                                    session_id: backendParams.sessionId,\n                                    attemptid: backendParams.attemptid,\n                                    userid: backendParams.userid,\n                                    quizid: backendParams.quizid,\n                                    slot: backendParams.slot ?? null,\n                                    events: events\n                                }\n                            }])[0].then((response) => {\n                                if (response && response.success) {\n                                    if (DEBUG_SHOW_CONSOLE_LOG) {\n                                        // eslint-disable-next-line no-console\n                                        console.log(\n                                            'User action(s) sent to server',\n                                            JSON.stringify(response, null, 2)\n                                        );\n                                    }\n                                    clearStoredEvents();\n                                } else {\n                                    // eslint-disable-next-line no-console\n                                    console.error('Server error saving events', response?.error);\n                                }\n                            }).catch((error) => {\n                                // eslint-disable-next-line no-console\n                                console.error('AJAX error saving events', error);\n                            });\n                        } else {\n                            if (DEBUG_SHOW_CONSOLE_LOG) {\n                                // eslint-disable-next-line no-console\n                                console.log('No user actions to save');\n                            }\n                        }\n                    };\n\n                    request.onerror = (error) => {\n                        // eslint-disable-next-line no-console\n                        console.error(\"Error retrieving events from IndexedDB:\", error);\n                    };\n                }\n            }\n\n            /**\n             * Clear all stored events from IndexedDB\n             * Called after successful server transmission\n             * @function clearStoredEvents\n             * @returns {void}\n             * @private\n             */\n            function clearStoredEvents() {\n                const transaction = db.transaction(\"events\", \"readwrite\");\n                const objectStore = transaction.objectStore(\"events\");\n                objectStore.clear();\n            }\n\n            initIndexedDB().then(() => {\n                initTracking();\n                setInterval(() => {\n                    flushEvents();\n                }, 5000);\n            }).catch((error) => {\n                // eslint-disable-next-line no-console\n                console.error(\"Failed to initialize IndexedDB:\", error);\n            });\n        };\n\n        userActivityTracker();\n    };\n\n    return {\n        init: init\n    };\n});\n"],"names":["define","Ajax","ExtensionDetector","SharedUtils","init","backendParams","startDetection","db","isCurrentlyFocused","document","hidden","extensionCheckInterval","extensionDetectedDataAlreadySent","Set","checkForNewExtensions","currentExtensions","metricsJSON","getMetrics","metrics","JSON","parse","timestamp","extensionDetection","console","warn","error","getExtensionsMetrics","newData","key","value","Object","entries","detectedElement","detected","_data","stringify","extensionKey","detectedElementUid","uid","has","add","push","name","length","logEvent","action","data","newEvent","objectStore","transaction","_newEvent","unix","generateTimestamp","undefined","trackDocumentState","event","type","target","window","visibilityState","previousState","initTracking","_trackingInitialized","url","location","href","referrer","userAgent","navigator","setInterval","addEventListener","selection","getSelection","copiedText","toString","anchorNode","qtextElement","currentElement","nodeType","Node","TEXT_NODE","parentElement","body","classList","contains","questionElement","questionIdPattern","id","test","content","questionId","trackCopy","clearInterval","flushEvents","request","getAll","onsuccess","events","filter","index","arr","nextAction","filterSpuriousEvents","result","map","_event$timestamp","call","methodname","args","session_id","sessionId","attemptid","userid","quizid","slot","then","response","success","clear","clearStoredEvents","catch","onerror","Promise","resolve","reject","indexedDB","open","onupgradeneeded","database","objectStoreNames","createObjectStore","autoIncrement","userActivityTracker"],"mappings":"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"}
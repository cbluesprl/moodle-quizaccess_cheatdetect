{"version":3,"file":"index.min.js","sources":["../../src/tracking/index.js"],"sourcesContent":["/**\n * @fileoverview Module de tracking d'activité utilisateur avec détection d'événements suspects\n * @module quizaccess_cheatdetect/tracking/index\n * @copyright 2025 CBlue SRL <support@cblue.be>\n * @license http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n * @since 1.0.0\n */\n\ndefine([\n    'quizaccess_cheatdetect/extension-detector/index',\n    'quizaccess_cheatdetect/shared/utils',\n    'quizaccess_cheatdetect/shared/modal'\n], function (ExtensionDetector, SharedUtils, Modal) {\n    'use strict';\n\n    /**\n     * @typedef {Object} BackendParams\n     * @property {boolean} [startDetection=true] - Active/désactive le tracking\n     * @property {string} [sessionId] - ID de session\n     * @property {number} [attemptid] - ID de la tentative\n     * @property {number} [userid] - ID de l'utilisateur\n     * @property {number} [quizid] - ID du quiz\n     * @property {number} [slot] - Numéro de slot de question\n     */\n\n    /**\n     * @typedef {Object} UserEvent\n     * @property {Object} timestamp - Horodatage avec timezone\n     * @property {string} action - Type d'action effectuée\n     * @property {Object} data - Données associées à l'événement\n     */\n\n    /**\n     * @typedef {Object} FieldModificationData\n     * @property {Object} target - Informations sur l'élément cible\n     * @property {number} valueLength - Longueur de la valeur saisie\n     * @property {string} userValue - Valeur saisie par l'utilisateur\n     */\n\n    var init = function (backendParams) {\n\n        const userActivityTracker = () => {\n            let db = null;\n            let isCurrentlyFocused = !document.hidden;\n\n            let lastCopyTime = null;\n            let lastCopyContent = \"\";\n\n            let lastKnownExtensions = {};\n            let extensionCheckInterval = null;\n            let extensionDetectedDataAlreadySent = new Set();\n\n            let pendingModalEvents = [];\n\n            function getExtensionsMetrics() {\n                try {\n                    const metricsJSON = ExtensionDetector.getMetrics();\n\n                    const metrics = JSON.parse(metricsJSON);\n\n                    if (!metrics.timestamp || !metrics.extensionDetection) {\n                        console.warn('Extension Detector: Structure de métriques invalide reçue');\n                        return {};\n                    }\n\n                    return metrics.extensionDetection;\n\n                } catch (error) {\n                    console.warn('Extension Detector: Erreur lors de la récupération des métriques d\\'extension:', error);\n                    return {};\n                }\n            }\n\n            function checkForNewExtensions() {\n                const currentExtensions = getExtensionsMetrics();\n                const newData = [];\n\n                for (const [key, value] of Object.entries(currentExtensions)) {\n                    for (const detectedElement of value.detected) {\n                        const _data = JSON.stringify({ extensionKey: key, detectedElementUid: detectedElement.uid });\n                        if (!extensionDetectedDataAlreadySent.has(_data)) {\n                            extensionDetectedDataAlreadySent.add(_data);\n                            newData.push(detectedElement);\n                        }\n                    }\n                }\n\n                if (newData.length > 0) {\n                    logEvent({\n                        action: \"extensions_detected\",\n                        data: newData\n                    });\n                }\n            }\n\n            function modalEventLogger(event) {\n\n                if (!db) {\n                    pendingModalEvents.push(event);\n                    return;\n                }\n\n                logEvent(event);\n            }\n\n            function flushPendingModalEvents() {\n                if (pendingModalEvents.length > 0 && db) {\n                    console.log('Vidage de événement(s) de modale en attente');\n\n                    pendingModalEvents.forEach(event => {\n                        logEvent(event);\n                    });\n\n                    pendingModalEvents = [];\n                }\n            }\n\n            function startExtensionMonitoring() {\n                checkForNewExtensions();\n\n                const initialExtensions = getExtensionsMetrics();\n                lastKnownExtensions = initialExtensions;\n\n                extensionCheckInterval = setInterval(() => {\n                    checkForNewExtensions();\n                }, 5000);\n            }\n\n            function stopExtensionMonitoring() {\n                if (extensionCheckInterval) {\n                    clearInterval(extensionCheckInterval);\n                    extensionCheckInterval = null;\n                }\n            }\n\n            function checkIndexedDBAvailability() {\n                return window.indexedDB;\n            }\n\n            function initIndexedDB() {\n                return new Promise((resolve, reject) => {\n                    if (!checkIndexedDBAvailability()) {\n                        reject(\"IndexedDB n'est pas disponible.\");\n                        return;\n                    }\n\n                    const request = indexedDB.open(\"UserActivityDB\", 1);\n\n                    request.onupgradeneeded = (event) => {\n                        const database = event.target.result;\n                        if (!database.objectStoreNames.contains(\"events\")) {\n                            database.createObjectStore(\"events\", {autoIncrement: true});\n                        }\n                    };\n\n                    request.onsuccess = (event) => {\n                        db = event.target.result;\n\n                        flushPendingModalEvents();\n\n                        resolve();\n                    };\n\n                    request.onerror = (event) => {\n                        console.error(\"Erreur lors de l'ouverture d'IndexedDB:\", event.target.error);\n                        reject(event.target.error);\n                    };\n                });\n            }\n\n            function logEvent(newEvent) {\n                if (db) {\n                    const transaction = db.transaction(\"events\", \"readwrite\");\n                    const objectStore = transaction.objectStore(\"events\");\n\n                    const _newEvent = {\n                        timestamp: SharedUtils.generateTimestamp(),\n                        ...newEvent\n                    };\n\n                    console.log('Nouvelle action utilisateur stockée', _newEvent);\n                    objectStore.add(_newEvent);\n                }\n            }\n\n            function trackFieldModification(event) {\n                const element = event.target;\n                const tagName = element.tagName.toLowerCase();\n\n                if (!['input', 'textarea', 'select'].includes(tagName)) {\n                    return;\n                }\n\n                let userValue;\n                if (element.type === 'checkbox') {\n                    userValue = element.checked ? element.value : null;\n                } else if (element.type === 'radio') {\n                    userValue = element.checked ? element.value : null;\n                } else {\n                    userValue = element.value;\n                }\n\n                if (element.type === 'radio' && !element.checked) {\n                    return;\n                }\n\n                const attributesObject = Object.fromEntries(\n                    element.getAttributeNames().map(attr => [attr, element.getAttribute(attr)])\n                );\n\n                const newEvent = {\n                    action: \"field_modified\",\n                    data: {\n                        target: {\n                            tag: tagName,\n                            attributes: attributesObject\n                        },\n                        valueLength: userValue ? userValue.length : 0,\n                        userValue: userValue,\n                    }\n                };\n\n                logEvent(newEvent);\n            }\n\n            function trackDocumentState(event) {\n                const now = performance.now();\n                let type = event.type;\n\n                if (event.type === 'visibilitychange') {\n                    if (document.visibilityState === 'visible') {\n                        type = 'focus';\n                    } else if (document.visibilityState === 'hidden') {\n                        type = 'blur';\n                    }\n                }\n\n                if (type === 'focus') {\n                    if (!isCurrentlyFocused) {\n                        isCurrentlyFocused = true;\n\n                        const focusEvent = {\n                            action: \"page_foreground\",\n                            data: {\n                                previousState: \"background\"\n                            }\n                        };\n                        logEvent(focusEvent);\n                    }\n                } else if (type === 'blur') {\n                    if (isCurrentlyFocused) {\n                        isCurrentlyFocused = false;\n\n                        const blurEvent = {\n                            action: \"page_background\",\n                            data: {\n                                previousState: \"foreground\"\n                            }\n                        };\n                        logEvent(blurEvent);\n\n                        checkSuspiciousCopyThenBackground(now);\n                    }\n                }\n            }\n\n            function trackCopy(event) {\n                const copiedText = window.getSelection().toString();\n                if (copiedText) {\n                    lastCopyTime = performance.now();\n                    lastCopyContent = copiedText;\n\n                    const newEvent = {\n                        action: \"copy\",\n                        data: {\n                            content: copiedText\n                        }\n                    };\n                    logEvent(newEvent);\n                }\n            }\n\n            function trackPaste(event) {\n                const pastedText = (event.clipboardData || window.clipboardData)?.getData(\"text\");\n                if (pastedText) {\n                    const element = event.target;\n                    const tagName = element.tagName.toLowerCase();\n                    const pasteSameAsCopy = pastedText === lastCopyContent;\n                    const attributesObject = Object.fromEntries(\n                        element.getAttributeNames().map(attr => [attr, element.getAttribute(attr)])\n                    );\n\n                    const newEvent = {\n                        action: \"paste\",\n                        data: {\n                            content: pastedText,\n                            pasteSameAsCopy: pasteSameAsCopy,\n                            target: {\n                                tag: tagName,\n                                attributes: attributesObject\n                            }\n                        }\n                    };\n                    logEvent(newEvent);\n\n                    if (!lastCopyContent || pastedText !== lastCopyContent) {\n                        const suspiciousEvent = {\n                            action: \"paste_different_content\",\n                            data: {\n                                lastCopy: lastCopyContent || null,\n                                currentPaste: pastedText,\n                                target: {\n                                    tag: tagName,\n                                    attributes: attributesObject\n                                }\n                            }\n                        };\n                        logEvent(suspiciousEvent);\n                    }\n                }\n            }\n\n            function checkSuspiciousCopyThenBackground(currentTime) {\n                if (lastCopyTime && lastCopyContent) {\n                    const timeSinceCopy = currentTime - lastCopyTime;\n\n                    if (timeSinceCopy < 30000) {\n                        const suspiciousEvent = {\n                            action: \"copy_then_background\",\n                            data: {\n                                copiedContent: lastCopyContent\n                            }\n                        };\n                        logEvent(suspiciousEvent);\n\n                        lastCopyTime = null;\n                        lastCopyContent = \"\";\n                    }\n                }\n            }\n\n            function initTracking() {\n                if (window._trackingInitialized) {\n                    console.warn('Tracking déjà initialisé, ignoré');\n                    return;\n                }\n                window._trackingInitialized = true;\n\n                const pageLoadEvent = {\n                    action: \"page_load\",\n                    data: {\n                        url: window.location.href,\n                        referrer: document.referrer || null,\n                        userAgent: navigator.userAgent\n                    }\n                };\n                logEvent(pageLoadEvent);\n\n                startExtensionMonitoring();\n\n                document.addEventListener(\"visibilitychange\", trackDocumentState);\n\n                document.addEventListener(\"blur\", trackDocumentState, true);\n\n                window.addEventListener(\"focus\", trackDocumentState);\n\n                window.addEventListener(\"blur\", trackDocumentState);\n\n                document.addEventListener(\"copy\", (event) => trackCopy(event));\n\n                document.addEventListener(\"paste\", (event) => trackPaste(event));\n\n                document.addEventListener(\"cut\", (event) => trackCopy(event));\n\n                document.addEventListener(\"input\", (event) => trackFieldModification(event));\n                document.addEventListener(\"change\", (event) => trackFieldModification(event));\n\n                window.addEventListener(\"beforeunload\", () => {\n                    stopExtensionMonitoring();\n\n                    const pageUnloadEvent = {\n                        action: \"page_unload\",\n                        data: {}\n                    };\n                    logEvent(pageUnloadEvent);\n\n                    flushEvents();\n                });\n\n                trackDocumentState({type: 'visibilitychange'});\n            }\n\n            function flushEvents() {\n                if (db) {\n                    const transaction = db.transaction(\"events\", \"readonly\");\n                    const objectStore = transaction.objectStore(\"events\");\n                    const request = objectStore.getAll();\n\n                    request.onsuccess = () => {\n                        const events = request.result;\n                        if (events.length > 0) {\n                            const data = {\n                                session_id: backendParams.sessionId,\n                                attemptid: backendParams.attemptid,\n                                userid: backendParams.userid,\n                                quizid: backendParams.quizid,\n                                slot: backendParams.slot,\n                                events: events\n                            };\n\n                            fetch('/local/rest/api/quizaccess_cheatdetect/save-data', {\n                                method: 'POST',\n                                headers: {\n                                    'Content-Type': 'application/json'\n                                },\n                                body: JSON.stringify(data)\n                            }).then(response => {\n                                if (response.ok) {\n                                    console.log('action(s) utilisateur envoyée(s) au serveur', data);\n                                    clearStoredEvents();\n                                } else {\n                                    console.error('Erreur lors de l\\'envoi des événements');\n                                }\n                            }).catch(error => {\n                                console.error('Erreur réseau:', error);\n                            });\n                        } else {\n                            console.log('Aucune action utilisateur à sauvegarder');\n                        }\n                    };\n\n                    request.onerror = (error) => {\n                        console.error(\"Erreur lors de la récupération des événements depuis IndexedDB:\", error);\n                    };\n                }\n            }\n\n            function clearStoredEvents() {\n                const transaction = db.transaction(\"events\", \"readwrite\");\n                const objectStore = transaction.objectStore(\"events\");\n                objectStore.clear();\n            }\n\n            Modal.setEventLogger(modalEventLogger);\n\n            initIndexedDB().then(() => {\n                initTracking();\n                setInterval(() => {\n                    flushEvents();\n                }, 5000);\n            }).catch((error) => {\n                console.error(\"Échec de l'initialisation d'IndexedDB:\", error);\n            });\n        };\n\n        userActivityTracker();\n    };\n\n    return {\n        init: init\n    };\n});\n"],"names":["define","ExtensionDetector","SharedUtils","Modal","init","backendParams","userActivityTracker","db","isCurrentlyFocused","document","hidden","lastCopyTime","lastCopyContent","lastKnownExtensions","extensionCheckInterval","extensionDetectedDataAlreadySent","Set","pendingModalEvents","getExtensionsMetrics","metricsJSON","getMetrics","metrics","JSON","parse","timestamp","extensionDetection","console","warn","error","checkForNewExtensions","currentExtensions","newData","key","value","Object","entries","detectedElement","detected","_data","stringify","extensionKey","detectedElementUid","uid","has","add","push","length","logEvent","action","data","newEvent","objectStore","transaction","_newEvent","_objectSpread","generateTimestamp","log","trackFieldModification","event","element","target","tagName","toLowerCase","includes","userValue","type","checked","tag","attributes","fromEntries","getAttributeNames","map","attr","getAttribute","valueLength","trackDocumentState","now","performance","visibilityState","previousState","currentTime","copiedContent","checkSuspiciousCopyThenBackground","trackCopy","copiedText","window","getSelection","toString","content","initTracking","_trackingInitialized","url","location","href","referrer","userAgent","navigator","initialExtensions","setInterval","startExtensionMonitoring","addEventListener","_ref","pastedText","clipboardData","getData","pasteSameAsCopy","attributesObject","lastCopy","currentPaste","trackPaste","clearInterval","flushEvents","request","getAll","onsuccess","events","result","session_id","sessionId","attemptid","userid","quizid","slot","fetch","method","headers","body","then","response","ok","clear","clearStoredEvents","catch","onerror","setEventLogger","Promise","resolve","reject","indexedDB","open","onupgradeneeded","database","objectStoreNames","contains","createObjectStore","autoIncrement","forEach"],"mappings":"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"}
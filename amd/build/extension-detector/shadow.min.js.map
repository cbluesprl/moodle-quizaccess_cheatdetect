{"version":3,"file":"shadow.min.js","sources":["../../src/extension-detector/shadow.js"],"sourcesContent":["/**\n * @fileoverview Shadow DOM monitor for extension element detection\n * @module quizaccess_cheatdetect/extension-detector/shadow\n * @copyright 2025 CBlue SRL <support@cblue.be>\n * @license http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n * @since 1.0.0\n */\n\ndefine([\n    'quizaccess_cheatdetect/extension-detector/config'\n], function(Config) {\n    'use strict';\n\n    /**\n     * @typedef {Object} ElementInfo\n     * @property {string} DOM - Element outer HTML\n     * @property {string|null} shadowDOM - Shadow DOM HTML if present\n     * @property {string} detection - Detection method used\n     */\n\n    /**\n     * @typedef {Object} ShadowMonitorState\n     * @property {boolean} hasDetectedElements - At least one element detected\n     * @property {number} totalDetections - Total number of detections\n     */\n\n    /**\n     * Shadow DOM monitor constructor\n     * @class ShadowMonitor\n     * @param {Function} onDetected - Callback called when extension is detected\n     * @example\n     * const monitor = new ShadowMonitor((key, ext, method) => {\n     *   console.log('Extension detected:', ext.name);\n     * });\n     * @since 1.0.0\n     */\n    var ShadowMonitor = function(onDetected) {\n        this.onDetected = onDetected;\n        this.onExtensionIdDetected = null; // Callback for ID detection\n        this.observers = new Map();\n        this.processedShadowRoots = new WeakSet();\n        this.detectedExtensions = new Set();\n        this.detectedExtensionIds = new Set(); // To avoid duplicate ID detections\n        this.isActive = false;\n        this.scanInterval = null;\n        this.metricsManager = null;\n\n        // Simple metrics state\n        this.metricsState = {\n            hasDetectedElements: false,\n            totalDetections: 0\n        };\n    };\n\n    /**\n     * Set the metrics manager reference\n     * @memberof ShadowMonitor\n     * @function setMetricsManager\n     * @param {Object} metricsManager - Metrics manager instance\n     * @example\n     * monitor.setMetricsManager(metricsManagerInstance);\n     * @since 1.0.0\n     */\n    ShadowMonitor.prototype.setMetricsManager = function(metricsManager) {\n        this.metricsManager = metricsManager;\n    };\n\n    /**\n     * Set the callback for extension ID detection\n     * @memberof ShadowMonitor\n     * @function setExtensionIdDetectedCallback\n     * @param {Function} callback - Callback called when extension ID is detected\n     * @example\n     * monitor.setExtensionIdDetectedCallback((extensionKey, extensionId, extensionPath) => {\n     *   console.log('ID detected:', extensionId);\n     * });\n     * @since 1.0.0\n     */\n    ShadowMonitor.prototype.setExtensionIdDetectedCallback = function(callback) {\n        this.onExtensionIdDetected = callback;\n    };\n\n    /**\n     * Start DOM and Shadow DOM monitoring\n     * @memberof ShadowMonitor\n     * @function start\n     * @throws {Error} If startup fails\n     * @example\n     * monitor.start();\n     * @since 1.0.0\n     */\n    ShadowMonitor.prototype.start = function() {\n        if (this.isActive) {\n            return;\n        }\n\n        this.isActive = true;\n\n        try {\n            this._scanAllElements();\n            this._createObserver();\n            this._startPeriodicScan();\n        } catch (error) {\n            // eslint-disable-next-line no-console\n            console.error('ðŸ§© Extension Detector: Failed to start monitoring', error);\n            this.isActive = false;\n        }\n    };\n\n    /**\n     * Start periodic element scanning\n     * @memberof ShadowMonitor\n     * @function _startPeriodicScan\n     * @private\n     * @since 1.0.0\n     */\n    ShadowMonitor.prototype._startPeriodicScan = function() {\n        var self = this;\n\n        this.scanInterval = setInterval(function() {\n            if (!self.isActive) {\n                return;\n            }\n            self._scanAllElements();\n        }, 1000);\n    };\n\n    /**\n     * Scan all document elements\n     * @memberof ShadowMonitor\n     * @function _scanAllElements\n     * @private\n     * @since 1.0.0\n     */\n    ShadowMonitor.prototype._scanAllElements = function() {\n        try {\n            var allElements = document.querySelectorAll('*');\n\n            for (var i = 0; i < allElements.length; i++) {\n                var element = allElements[i];\n\n                this._checkAndProcessElement(element, 'periodicScan');\n\n                if (element.shadowRoot && !this.processedShadowRoots.has(element.shadowRoot)) {\n                    this._handleShadowRoot(element);\n                }\n            }\n        } catch (error) {\n            if (Config.SETTINGS.enableLogging) {\n                // eslint-disable-next-line no-console\n                console.warn('ðŸ§© Extension Detector: Error during periodic scan', error);\n            }\n        }\n    };\n\n    /**\n     * Create a MutationObserver to monitor DOM changes\n     * @memberof ShadowMonitor\n     * @function _createObserver\n     * @private\n     * @since 1.0.0\n     */\n    ShadowMonitor.prototype._createObserver = function() {\n        var self = this;\n\n        var observer = new MutationObserver(function(mutations) {\n            if (!self.isActive) {\n                return;\n            }\n\n            mutations.forEach(function(mutation) {\n                if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {\n                    mutation.addedNodes.forEach(function(node) {\n                        if (node.nodeType === Node.ELEMENT_NODE) {\n                            self._checkAndProcessElement(node, 'mutationObserver');\n\n                            if (node.querySelectorAll) {\n                                var children = node.querySelectorAll('*');\n                                for (var i = 0; i < children.length; i++) {\n                                    self._checkAndProcessElement(children[i], 'mutationObserver');\n                                }\n                            }\n\n                            if (node.shadowRoot) {\n                                self._handleShadowRoot(node);\n                            }\n                        }\n                    });\n                }\n\n                if (mutation.type === 'attributes') {\n                    var target = mutation.target;\n                    if (target && target.nodeType === Node.ELEMENT_NODE) {\n                        self._checkAndProcessElement(target, 'attributeChange');\n                    }\n                }\n            });\n        });\n\n        observer.observe(document, {\n            childList: true,\n            subtree: true,\n            attributes: true\n        });\n\n        this.observers.set('main', observer);\n    };\n\n    /**\n     * Check and process an element to detect extensions\n     * @memberof ShadowMonitor\n     * @function _checkAndProcessElement\n     * @param {Element} element - Element to check\n     * @returns {boolean} True if an extension was detected\n     * @private\n     * @since 1.0.0\n     */\n    ShadowMonitor.prototype._checkAndProcessElement = function(element) {\n        if (!element) {\n            return false;\n        }\n\n        var extensions = Config.getAllExtensions();\n\n        for (var i = 0; i < extensions.length; i++) {\n            var extension = extensions[i];\n\n            if (this._detectExtensionElement(element, extension)) {\n                this._processDetectedElement(extension.key, element);\n                return true;\n            }\n        }\n\n        return false;\n    };\n\n    /**\n     * Detect if an element belongs to an extension\n     * @memberof ShadowMonitor\n     * @function _detectExtensionElement\n     * @param {Element} element - Element to analyze\n     * @param {Object} extension - Extension configuration\n     * @returns {boolean} True if element belongs to the extension\n     * @private\n     * @since 1.0.0\n     */\n    ShadowMonitor.prototype._detectExtensionElement = function(element, extension) {\n        if (!extension) {\n            return false;\n        }\n\n        // SECURITY: Never try to remove critical elements\n        if (element === document.body || element === document.documentElement ||\n            element.tagName === 'BODY' || element.tagName === 'HTML' || element.tagName === 'HEAD') {\n            return false;\n        }\n\n        // 1. First check by extension ID (static or dynamic)\n        if (this._containsAnyExtensionId(element, extension)) {\n            return true;\n        }\n\n        // 2. Detect by keywords/id/class and extract extension ID if found\n        var detectedByPattern = false;\n\n        if (extension.textKeywords && element.textContent) {\n            for (var k = 0; k < extension.textKeywords.length; k++) {\n                var keyword = extension.textKeywords[k];\n                if (element.textContent.includes(keyword)) {\n                    detectedByPattern = true;\n                    break;\n                }\n            }\n        }\n\n        if (!detectedByPattern && extension.patterns.ids && element.id) {\n            var elementId = element.id.toLowerCase();\n            for (var j = 0; j < extension.patterns.ids.length; j++) {\n                var pattern = extension.patterns.ids[j].toLowerCase();\n                if (elementId.includes(pattern)) {\n                    detectedByPattern = true;\n                    break;\n                }\n            }\n        }\n\n        if (!detectedByPattern && extension.patterns.classes && element.className) {\n            var className = element.className.toLowerCase();\n            for (var i = 0; i < extension.patterns.classes.length; i++) {\n                var classPattern = extension.patterns.classes[i].toLowerCase();\n                if (className.includes(classPattern)) {\n                    detectedByPattern = true;\n                    break;\n                }\n            }\n        }\n\n        // If detected by pattern, try to extract extension ID\n        if (detectedByPattern) {\n            this._extractAndStoreExtensionId(element, extension);\n            return true;\n        }\n\n        return false;\n    };\n\n    /**\n     * Process a detected element (logging and removal)\n     * @memberof ShadowMonitor\n     * @function _processDetectedElement\n     * @param {string} extensionKey - Extension key\n     * @param {Element} element - Detected element\n     * @private\n     * @since 1.0.0\n     */\n    ShadowMonitor.prototype._processDetectedElement = function(extensionKey, element) {\n        this.metricsState.totalDetections++;\n\n        // Extract element information\n        var elementInfo = this._extractElementInfo(element);\n\n        // Log detection (ALWAYS)\n        if (this.metricsManager) {\n            this.metricsManager.logDetectedElement(extensionKey, elementInfo);\n\n            if (Config.SETTINGS.enableLogging) {\n                // eslint-disable-next-line no-console\n                console.log('ðŸ§© Extension Detector: ðŸš¨ ' + extensionKey + ' : element detected', elementInfo);\n            }\n        }\n\n        // Try to remove if setting allows\n        if (Config.SETTINGS.removeDetectedElements) {\n            var removed = this._tryRemoveElement(element);\n\n            if (removed) {\n                if (Config.SETTINGS.enableLogging) {\n\n                    // Console.log('ðŸ§© Extension Detector: âœ… ' + extensionKey + ' : element removed', elementInfo);\n                }\n            } else {\n                if (Config.SETTINGS.enableLogging) {\n                    // eslint-disable-next-line no-console\n                    console.log('ðŸ§© Extension Detector: âŒ ' + extensionKey +\n                        ' - element removal failed', elementInfo);\n                }\n            }\n        }\n\n        // FIX: ALWAYS notify on first detection\n        // even if startDetection = false in backend params\n        if (!this.detectedExtensions.has(extensionKey)) {\n            this.detectedExtensions.add(extensionKey);\n            if (this.onDetected) {\n                var extensionConfig = Config.getExtension(extensionKey);\n                this.onDetected(extensionKey, extensionConfig, 'DOM detection');\n            }\n        }\n    };\n\n    /**\n     * Extract relevant information from a detected element\n     * @memberof ShadowMonitor\n     * @function _extractElementInfo\n     * @param {Element} element - Element to analyze\n     * @returns {ElementInfo} Information extracted from the element\n     * @private\n     * @since 1.0.0\n     */\n    ShadowMonitor.prototype._extractElementInfo = function(element) {\n        var method = '';\n\n        // Determine method based on what triggered detection\n        var extensions = Config.getAllExtensions();\n        for (var i = 0; i < extensions.length; i++) {\n            var extension = extensions[i];\n            if (this._containsAnyExtensionId(element, extension)) {\n                // Extract just the extension ID found in the element\n                var outerHTML = element.outerHTML;\n                var shadowHTML = element.shadowRoot ? element.shadowRoot.innerHTML : '';\n                var combinedHTML = outerHTML + shadowHTML;\n                var match = combinedHTML.match(Config.EXTENSION_URL_REGEX);\n                if (match && match[2]) {\n                    method = 'Browser extension found by extension ID: ' + match[2];\n                } else {\n                    method = 'Browser extension found';\n                }\n                break;\n            } else if (extension.textKeywords && element.textContent) {\n                var found = false;\n                for (var l = 0; l < extension.textKeywords.length; l++) {\n                    if (element.textContent.includes(extension.textKeywords[l])) {\n                        method = 'Text keyword found: ' + extension.textKeywords[l];\n                        found = true;\n                        break;\n                    }\n                }\n                if (found) {\n                    break;\n                }\n            } else if (extension.patterns.ids && element.id) {\n                var elementId = element.id.toLowerCase();\n                for (var j = 0; j < extension.patterns.ids.length; j++) {\n                    var pattern = extension.patterns.ids[j].toLowerCase();\n                    if (elementId.includes(pattern)) {\n                        method = 'ID found: ' + pattern;\n                        found = true;\n                        break;\n                    }\n                }\n                if (found) {\n                    break;\n                }\n            } else if (extension.patterns.classes && element.className) {\n                var className = element.className.toLowerCase();\n                for (var k = 0; k < extension.patterns.classes.length; k++) {\n                    var classPattern = extension.patterns.classes[k].toLowerCase();\n                    if (className.includes(classPattern)) {\n                        method = 'Class found: ' + classPattern;\n                        found = true;\n                        break;\n                    }\n                }\n                if (found) {\n                    break;\n                }\n            }\n        }\n\n        return {\n            DOM: element.outerHTML,\n            shadowDOM: element.shadowRoot ? element.shadowRoot.innerHTML : null,\n            detection: method\n        };\n    };\n\n    /**\n     * Try to safely remove an element\n     * @memberof ShadowMonitor\n     * @function _tryRemoveElement\n     * @param {Element} element - Element to remove\n     * @returns {boolean} True if removal succeeded\n     * @private\n     * @since 1.0.0\n     */\n    ShadowMonitor.prototype._tryRemoveElement = function(element) {\n        if (!element ||\n            element === document.body ||\n            element === document.documentElement ||\n            element.tagName === 'BODY' ||\n            element.tagName === 'HTML' ||\n            element.tagName === 'HEAD') {\n            return false;\n        }\n\n        try {\n            if (element.parentNode) {\n                element.parentNode.removeChild(element);\n                return true;\n            } else if (element.remove) {\n                element.remove();\n                return true;\n            }\n        } catch (error) {\n            // Silent failure\n        }\n        return false;\n    };\n\n    /**\n     * Check if element contains an extension ID (static or dynamic)\n     * @memberof ShadowMonitor\n     * @function _containsAnyExtensionId\n     * @param {Element} element - Element to check\n     * @param {Object} extension - Extension configuration\n     * @returns {boolean} True if an extension ID is found\n     * @private\n     * @since 1.0.0\n     */\n    ShadowMonitor.prototype._containsAnyExtensionId = function(element, extension) {\n        var allIds = Config.getAllExtensionIds(extension.key);\n        if (!allIds || allIds.length === 0) {\n            return false;\n        }\n\n        var outerHTML = element.outerHTML;\n        var shadowHTML = element.shadowRoot ? element.shadowRoot.innerHTML : '';\n        var combinedHTML = outerHTML + shadowHTML;\n\n        // Check with regex to detect extension URLs\n        var match = combinedHTML.match(Config.EXTENSION_URL_REGEX);\n        if (!match) {\n            return false;\n        }\n\n        var foundExtensionId = match[2]; // ID extracted from regex\n\n        // Check if found ID matches one of configured IDs (static or dynamic)\n        return allIds.indexOf(foundExtensionId) !== -1;\n    };\n\n    /**\n     * Extract extension ID from element content and store it\n     * @memberof ShadowMonitor\n     * @function _extractAndStoreExtensionId\n     * @param {Element} element - Element to analyze\n     * @param {Object} extension - Extension configuration\n     * @private\n     * @since 1.0.0\n     */\n    ShadowMonitor.prototype._extractAndStoreExtensionId = function(element, extension) {\n        var outerHTML = element.outerHTML;\n        var shadowHTML = element.shadowRoot ? element.shadowRoot.innerHTML : '';\n        var combinedHTML = outerHTML + shadowHTML;\n\n        // Search all extension URL occurrences\n        var regex = new RegExp(Config.EXTENSION_URL_REGEX, 'g');\n        var match;\n\n        while ((match = regex.exec(combinedHTML)) !== null) {\n            var extensionProtocol = match[1]; // chrome-extension:// or moz-extension://\n            var extensionId = match[2];\n            var extensionPath = extensionProtocol + extensionId;\n\n            // Avoid processing the same ID multiple times\n            if (this.detectedExtensionIds.has(extensionPath)) {\n                continue;\n            }\n\n            this.detectedExtensionIds.add(extensionPath);\n\n            // Add ID to configuration\n            var added = Config.addDetectedExtensionId(extension.key, extensionId);\n\n            if (added && Config.SETTINGS.enableLogging) {\n                // eslint-disable-next-line no-console\n                console.log('ðŸ§© Extension Detector: New extension ID extracted for ' +\n                    extension.name + ': ' + extensionId);\n            }\n\n            // Notify main detector to remove all elements with this ID\n            if (this.onExtensionIdDetected && added) {\n                this.onExtensionIdDetected(extension.key, extensionId);\n            }\n        }\n    };\n\n    /**\n     * Check extension ID with multi-browser regex (legacy)\n     * @memberof ShadowMonitor\n     * @function _containsSpecificExtensionId\n     * @param {Element} element - Element to check\n     * @param {Object} extension - Extension configuration\n     * @returns {boolean} True if extension ID is found\n     * @private\n     * @deprecated Use _containsAnyExtensionId instead\n     * @since 1.0.0\n     */\n    ShadowMonitor.prototype._containsSpecificExtensionId = function(element, extension) {\n        return this._containsAnyExtensionId(element, extension);\n    };\n\n    /**\n     * Handle a detected Shadow Root\n     * @memberof ShadowMonitor\n     * @function _handleShadowRoot\n     * @param {Element} element - Element containing the Shadow Root\n     * @private\n     * @since 1.0.0\n     */\n    ShadowMonitor.prototype._handleShadowRoot = function(element) {\n        var shadowRoot = element.shadowRoot;\n        if (this.processedShadowRoots.has(shadowRoot)) {\n            return;\n        }\n\n        this.processedShadowRoots.add(shadowRoot);\n        this._observeShadowRoot(shadowRoot);\n        this._scanShadowRoot(shadowRoot);\n    };\n\n    /**\n     * Observe changes in a Shadow Root\n     * @memberof ShadowMonitor\n     * @function _observeShadowRoot\n     * @param {ShadowRoot} shadowRoot - Shadow Root to observe\n     * @private\n     * @since 1.0.0\n     */\n    ShadowMonitor.prototype._observeShadowRoot = function(shadowRoot) {\n        if (this.observers.has(shadowRoot)) {\n            return;\n        }\n\n        var self = this;\n        var shadowObserver = new MutationObserver(function(mutations) {\n            if (!self.isActive) {\n                return;\n            }\n\n            mutations.forEach(function(mutation) {\n                if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {\n                    mutation.addedNodes.forEach(function(node) {\n                        if (node.nodeType === Node.ELEMENT_NODE) {\n                            self._checkAndProcessElement(node, 'shadowDOM');\n                        }\n                    });\n                }\n            });\n        });\n\n        shadowObserver.observe(shadowRoot, {\n            childList: true,\n            subtree: true,\n            attributes: true\n        });\n\n        this.observers.set(shadowRoot, shadowObserver);\n    };\n\n    /**\n     * Scan all elements in a Shadow Root\n     * @memberof ShadowMonitor\n     * @function _scanShadowRoot\n     * @param {ShadowRoot} shadowRoot - Shadow Root to scan\n     * @private\n     * @since 1.0.0\n     */\n    ShadowMonitor.prototype._scanShadowRoot = function(shadowRoot) {\n        try {\n            var elements = shadowRoot.querySelectorAll('*');\n            for (var i = 0; i < elements.length; i++) {\n                this._checkAndProcessElement(elements[i], 'shadowDOM');\n            }\n        } catch (error) {\n            // Silent failure\n        }\n    };\n\n    /**\n     * Stop monitoring\n     * @memberof ShadowMonitor\n     * @function stop\n     * @example\n     * monitor.stop();\n     * @since 1.0.0\n     */\n    ShadowMonitor.prototype.stop = function() {\n        if (!this.isActive) {\n            return;\n        }\n\n        this.isActive = false;\n\n        if (this.scanInterval) {\n            clearInterval(this.scanInterval);\n            this.scanInterval = null;\n        }\n\n        this._cleanup();\n    };\n\n    /**\n     * Cleanup used resources\n     * @memberof ShadowMonitor\n     * @function _cleanup\n     * @private\n     * @since 1.0.0\n     */\n    ShadowMonitor.prototype._cleanup = function() {\n        this.observers.forEach(function(observer) {\n            try {\n                observer.disconnect();\n            } catch (error) {\n                // Silent failure\n            }\n        });\n\n        this.observers.clear();\n        this.processedShadowRoots = new WeakSet();\n        this.detectedExtensions.clear();\n    };\n\n    /**\n     * Reset monitor state\n     * @memberof ShadowMonitor\n     * @function reset\n     * @example\n     * monitor.reset();\n     * @since 1.0.0\n     */\n    ShadowMonitor.prototype.reset = function() {\n        this.detectedExtensions.clear();\n        this.detectedExtensionIds.clear();\n        this.metricsState = {\n            hasDetectedElements: false,\n            totalDetections: 0\n        };\n    };\n\n    return {\n        ShadowMonitor: ShadowMonitor\n    };\n});\n"],"names":["define","Config","ShadowMonitor","onDetected","this","onExtensionIdDetected","observers","Map","processedShadowRoots","WeakSet","detectedExtensions","Set","detectedExtensionIds","isActive","scanInterval","metricsManager","metricsState","hasDetectedElements","totalDetections","prototype","setMetricsManager","setExtensionIdDetectedCallback","callback","start","_scanAllElements","_createObserver","_startPeriodicScan","error","console","self","setInterval","allElements","document","querySelectorAll","i","length","element","_checkAndProcessElement","shadowRoot","has","_handleShadowRoot","SETTINGS","enableLogging","warn","observer","MutationObserver","mutations","forEach","mutation","type","addedNodes","node","nodeType","Node","ELEMENT_NODE","children","target","observe","childList","subtree","attributes","set","extensions","getAllExtensions","extension","_detectExtensionElement","_processDetectedElement","key","body","documentElement","tagName","_containsAnyExtensionId","detectedByPattern","textKeywords","textContent","k","keyword","includes","patterns","ids","id","elementId","toLowerCase","j","pattern","classes","className","classPattern","_extractAndStoreExtensionId","extensionKey","elementInfo","_extractElementInfo","logDetectedElement","log","removeDetectedElements","_tryRemoveElement","add","extensionConfig","getExtension","method","match","outerHTML","innerHTML","EXTENSION_URL_REGEX","found","l","DOM","shadowDOM","detection","parentNode","removeChild","remove","allIds","getAllExtensionIds","foundExtensionId","indexOf","combinedHTML","regex","RegExp","exec","extensionProtocol","extensionId","extensionPath","added","addDetectedExtensionId","name","_containsSpecificExtensionId","_observeShadowRoot","_scanShadowRoot","shadowObserver","elements","stop","clearInterval","_cleanup","disconnect","clear","reset"],"mappings":"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"}